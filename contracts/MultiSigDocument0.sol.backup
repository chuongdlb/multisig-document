pragma solidity ^0.4.24;

import 'openzeppelin-solidity/contracts/ownership/Ownable.sol';
import 'openzeppelin-solidity/contracts/ECRecovery.sol';

contract IMultipleSignatory {
    function isValid() public constant returns (bool);
    function getValidDays() public constant returns (uint);
    function submitSignature(bytes signature) public;
    /* function addSigner(address newSigner) public; */
    /* function removeSigner(address signer) public; */
    function changeNumberOfRquiredSignatures(uint newRequiredNumber) public;
    function recoverSigner(bytes32 data, bytes signature) internal pure returns (address);
    function verifySignedDocument() public;
    function deactivate() public;
    event SignatureSubmission(address submitter, address indexed verifier);
    event TrustVerifierSignatureSubmission(address indexed verifier);
    event LogInvalidSignatureSubmission(address submitter);
    event LogNumOfRequiredSignatureChanged(uint oldNum, uint indexed newNum);
    event SignerRemoved(address indexed signer);
    event SignerAdded(address indexed signer);
    event Activation(address indexed activator);

}

contract MultiSigDocument is IMultipleSignatory, Ownable {
  using ECRecovery for bytes32;
  uint public constant MAX_SIGNER_COUNT = 10;

  /* string public constant ROLE_SIGNER = "signer";
  string public constant ROLE_VERIFIER = "verifier"; */
  uint public createdTime; //Timestamp
  uint public validDays = 365; //days
  uint public expiration = 2**256-1; // Default to infinitive - Timestamp
  bool public autoActivation = false;
  bool public verified = false;
  uint public allowModificationDeadline = 0; //Timestamp
  uint public numOfRequiredSignature;

  address public verifier;
  address public issuer;
  // Keep track of signers
  uint32 public signerCount = 0; // include issuer
  //
  uint8 public confirmationCount = 0;
  // signer list 
  mapping (uint => address) public signers;
  // signerAddr => is Sig. confirmed by verifier
  mapping (address => bool) public isSigned;
  // signerAddr => isSubmitted Sig.
  mapping (address => bool) public isSubmitted;
  // represent the trust of signers toward Verifier
  mapping (address => mapping (address => bool)) public trustedVoteForVerifier;
  // signerAdr => is set as a signer
  mapping (address => bool) public isSigner;

  modifier validRequirement(uint _signerCount,
                            uint _numOfRequiredSignature,
                            uint _validDays,
                            uint _allowRevocationPeriodInDays)
  {
      require(_signerCount > 0 && _signerCount <= MAX_SIGNER_COUNT);
      require(_numOfRequiredSignature > 0  && _numOfRequiredSignature < MAX_SIGNER_COUNT);
      require(_validDays > 0 && _allowRevocationPeriodInDays < _validDays);
      _;
  }
  modifier signerDoesNotExist(address signer) {
      require(!isSigner[signer]);
      _;
  }

  modifier beforeModificationDeadline() {
      require(now < allowModificationDeadline);
      _;
  }


  modifier signerExists(address signer) {
      require(isSigner[signer]);
      _;
  }
  modifier onlyVerifier() {
      require(verifier == msg.sender);
      _;
  }
  modifier trustedVerifier(address verifier) {
      assert(isTrustedVerifier(verifier));
      _;
  }
  modifier onlyIssuer() {
      require(issuer == msg.sender);
      _;
  }
  modifier notVerified() {
      assert(!verified);
      _;
  }

  function toBytes(uint256 x)
      internal
      pure
      returns (bytes b)
  {
      b = new bytes(32);
      assembly { mstore(add(b, 32), x) }
  }

  function toBytes(bool x)
      internal
      pure
      returns (bytes b)
  {
      b = new bytes(8);
      assembly { mstore(add(b, 8), x) }
  }


  constructor(address[] _signer,
              address _verifier,
              uint _numOfRequiredSignature,
              uint _validDays,
              uint _allowRevocationPeriodInDays)
      public
      validRequirement(_signer.length, _numOfRequiredSignature, _validDays, _allowRevocationPeriodInDays)
  {
      require(_verifier != address(0));
      for (uint i=0; i<_signer.length; i++) {
          assert(_signer[i] != address(0) && _signer[i] != _verifier && _signer[i] != msg.sender);
          isSigner[_signer[i]] = true;
          signers[signerCount++] = _signer[i];
      }
      verifier = _verifier;
      issuer = msg.sender;
      isSigner[issuer] = true;
      signers[signerCount++] = issuer;
      createdTime = now;
      validDays = _validDays;
      expiration = createdTime + (validDays * 1 days);
      numOfRequiredSignature = _numOfRequiredSignature + 1;
      allowModificationDeadline = createdTime + (_allowRevocationPeriodInDays * 1 days);
  }

  function grantVerifierWithTrust(bool trust, bytes sig)
      public
  {
      address recoveredAddr = recoverSigner(
        keccak256(abi.encodePacked(address(this), verifier)), sig);
      if(!isSigner[recoveredAddr]) {
        emit LogInvalidSignatureSubmission(msg.sender);
        revert('Look! Ethers are bleeding from your wallet!');
      }

      trustedVoteForVerifier[recoveredAddr][verifier] = trust;
      emit TrustVerifierSignatureSubmission(verifier);
  }

  /*
   * msg.sender who submits the signature does not need to be who created the signature
   */
  function submitSignature(bytes sig)
      public
  {
      if(!isValidSignature(sig)) {
        emit LogInvalidSignatureSubmission(msg.sender);
        revert('Submitting signature is invalid!');
      }

      address signer = recoverSigner(keccak256(abi.encodePacked(address(this), verifier, validDays)), sig);
      isSigned[signer] = true;
      confirmationCount++;
      /* signatures[countSignature] = signature;
      countSignature += 1; */
      emit SignatureSubmission(msg.sender, verifier);
      /* if(autoActivation && isValid()) {
        verifySignedDocument();
      } */
  }

  /* function addSigner(address _signer)
      public
      onlyVerifier()
      trustedVerifier(msg.sender)
      beforeModificationDeadline()
      signerDoesNotExist(_signer)
      notVerified()
  {
      require(_signer != verifier);
      signers[signerCount++] = _signer;
      isSigner[_signer] = true;
      emit SignerAdded(_signer);
  } */

  /* function removeSigner(address _signer)
      public
      onlyVerifier()
      trustedVerifier(msg.sender)
      beforeModificationDeadline()
      signerExists(_signer)
      notVerified()
  {
      require(_signer != verifier);
      isSigned[_signer] = false;
      isSigner[_signer] = false;
      confirmationCount--;

      emit SignerRemoved(_signer);

  } */

  function changeNumberOfRquiredSignatures(uint newRequiredNumber)
      public
      onlyVerifier()
      trustedVerifier(msg.sender)
      beforeModificationDeadline()
      notVerified()
  {
      require(newRequiredNumber > 0  && newRequiredNumber < signerCount);
      emit LogNumOfRequiredSignatureChanged(numOfRequiredSignature, newRequiredNumber);
      numOfRequiredSignature = newRequiredNumber;
  }

  function recoverSigner(bytes32 hash, bytes sig)
      internal
      pure
      returns (address)
  {
      return hash
       .toEthSignedMessageHash()
       .recover(sig);
  }
  /*
   * Just an example that the signature contains some knowledge that each signatory
   * has share and agree on it
   * Overload it if needed
   */
  function isValidSignature(bytes signature)
      internal
      constant
      returns (bool)
  {
      address recoveredAddr = recoverSigner(
        keccak256(abi.encodePacked(address(this), verifier, toBytes(validDays))), signature);

      return isSigner[recoveredAddr];
  }


  function isValid()
      public
      constant
      returns (bool)
  {

      if(!isSigned[issuer]) return false;
      if(confirmationCount < numOfRequiredSignature) return false;
      return true;
  }
  function isTrustedVerifier(address _verifier)
      public
      constant
      returns (bool)
  {

      uint8 confirmationCount = 0;
      for (uint8 i=0; i<signerCount; i++) {
          if (trustedVoteForVerifier[signers[i]][_verifier])
            confirmationCount++;
      }
      if(confirmationCount < numOfRequiredSignature) return false;
      return true;
  }
  function verifySignedDocument()
      public
      notVerified()
      trustedVerifier(msg.sender)
  {
      assert(isValid());
      verified = true;
      emit Activation(msg.sender);
  }

  function deactivate()
      signerExists(msg.sender)
      public
  {
      assert(now > expiration);
      selfdestruct(issuer);
  }

  function getHashSignature(bytes validSig)
      internal
      returns(bytes32)
  {
      return keccak256(abi.encodePacked(validSig));
  }

  function getValidDays() public constant returns (uint) {
      return validDays;
  }

}
